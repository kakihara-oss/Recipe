# CLAUDE.md - 感動創出レシピツール（Kando Recipe）

## プロジェクトビジョン

**「料理の可能性を拡張する感動創出のレシピツール」**

単なる調理方法の管理ではなく、料理とサービスを通じてお客様の人生に感動を届けるためのプラットフォーム。
レシピを中心に、シェフ・サービス・食材調達・総合プロデューサーが
店舗フィロソフィーに共感する仲間として一体となり、
商品とサービスを継続的にブラッシュアップしていく。

### レシピの位置づけ

レシピは「調理手順書」ではなく **「感動の設計図」**。以下の要素を統合する:
- **調理**: 食材の選定、調理手順、技法、温度管理
- **サービス**: 盛り付け、提供方法、顧客への声かけ、演出、ストーリーテリング
- **体験設計**: お客様にどんな感動を届けるか、記念日対応、季節の演出、五感への訴求
- **ナレッジ**: 料理の歴史、文化的背景、食材の物語、感動を生んだ事例

### コアバリュー
- 料理を如何にサービスに活かすか
- サービスを如何に料理に活かすか
- 料理とサービスを如何にお客様の人生に活かすか

商品はシェフだけでは完成しない。お客様の反応を元にブラッシュアップし続け、
商品開発・改良、サービス開発・改良の際にはAIに相談できる機能と、
そのためのナレッジ（感動を生む調理方法、演出方法、サービス方法、発信方法、歴史や事例など）を
組み込んでおくことで、チーム全員の創造性を拡張する。

## プロジェクト概要

- バックエンド: Spring Boot 3.x / Java 17 / Gradle
- データベース: PostgreSQL + Flyway（マイグレーション）
- 認証: Spring Security + Google OAuth2/OIDC（Google Workspace SSO）
- AI連携: LLM API（Claude API等）+ ナレッジベースによるコンテキスト付き相談
- API形式: REST API（フロントエンドはReact別リポジトリ）

---

## 開発フェーズ

### フェーズ1: プロジェクト基盤
Gradle初期化、Spring Boot設定、パッケージ構成、共通例外クラス、グローバル例外ハンドラ、定数クラス

### フェーズ2: Google Workspace認証 & アクセス制御
Google OAuth2ログイン（会社ドメイン限定）、Userエンティティ、ロール管理、
JWT発行、権限チェック、PRODUCERによるアクセス権限管理

### フェーズ3: 感動創出レシピ（コア機能）
Recipe・RecipeIngredient・CookingStep・ServiceDesign・ExperienceDesign、
RecipeHistory（変更履歴）、レシピCRUD API、ページネーション

### フェーズ4: ナレッジベース & AI相談
KnowledgeCategory・KnowledgeArticle（ナレッジ記事管理）、
AI相談機能（LLM連携・ナレッジをコンテキストとした対話型相談）、レシピ×ナレッジ連携

### フェーズ5: お客様フィードバック & 満足度・感動度
ProductFeedback（商品別の満足度・感動度の記録）、FeedbackSummary（集計・分析）、
フィードバックを元にしたレシピ改善サイクルの支援

### フェーズ6: 食材マスタ & 原価管理
Ingredient・IngredientPrice・IngredientSeason（食材マスタ・価格履歴・旬情報）、
RecipeCost（原価自動計算・推奨売価）、食材変更の影響分析、アーカイブ連動

### フェーズ7: 店舗・POSデータ & 経営分析
Store（店舗マスタ）、MonthlySales（POSデータCSV取込）、
StoreMonthlyFoodCost（理論原価）、店舗間比較、月次推移、満足度×収益クロス分析

---

## パッケージ構成

```
com.recipe.manager
├── config/          # Security, OAuth2, Web, DB, AI設定
├── controller/      # REST Controller
├── service/         # ビジネスロジック
├── repository/      # Spring Data JPA Repository
├── entity/          # JPA Entity
├── dto/
│   ├── request/     # リクエストDTO
│   └── response/    # レスポンスDTO
├── exception/       # カスタム例外
├── security/        # OAuth2, JWT, 認証・認可
├── ai/              # AI連携（LLMクライアント、プロンプト管理）
└── common/          # 定数, ユーティリティ
```

---

## 主要エンティティ

### レシピ関連（フェーズ3）
- Recipe: レシピ本体（タイトル、説明、カテゴリ、人数、ステータス、コンセプト、ストーリー）
- RecipeIngredient: レシピ内の食材情報（食材マスタへの参照、使用量、単位、下処理メモ、代替食材）
- CookingStep: 調理手順（手順番号、説明、所要時間、温度、コツ）
- ServiceDesign: サービス設計（盛り付け指示、提供方法、顧客への声かけスクリプト、演出方法、タイミング、ストーリーテリング要素）
- ExperienceDesign: 体験設計（ターゲットシーン、期待する感動ポイント、記念日対応、季節演出、五感への訴求）

### ナレッジ関連（フェーズ4）
- KnowledgeCategory: ナレッジカテゴリ（調理技法、演出方法、サービス手法、発信方法、歴史・文化、感動事例）
- KnowledgeArticle: ナレッジ記事（タイトル、本文、カテゴリ、タグ、投稿者、関連レシピ）
- AiConsultationThread: AI相談スレッド（ユーザー、関連レシピ、相談テーマ）
- AiConsultationMessage: AI相談メッセージ（スレッド、送信者種別[USER/AI]、メッセージ本文、参照ナレッジ）

### フィードバック関連（フェーズ5）
- ProductFeedback: 商品フィードバック（レシピ、店舗、評価期間、満足度スコア、感動度スコア（仮）、定性コメント、収集方法）
- FeedbackSummary: フィードバック集計（レシピ、期間、平均満足度、平均感動度、件数、主要コメント傾向）

### 食材マスタ関連（フェーズ6）
- Ingredient: 食材マスタ（食材名、カテゴリ、標準単位、季節フラグ、供給状態、仕入先）
- IngredientPrice: 食材価格履歴（単価、有効開始日、有効終了日） ※時系列で価格変動を追跡
- IngredientSeason: 食材の旬情報（対象月、入手性ランク、品質メモ）

### 原価・売価関連（フェーズ6）
- RecipeCost: レシピ原価情報（食材原価合計、目標粗利率、推奨売価、現在売価、最終計算日時）

### 店舗・売上関連（フェーズ7）
- Store: 店舗マスタ（店舗コード、店舗名、所在地）
- MonthlySales: 月次売上データ（店舗、レシピ、対象年月、出数、売上金額） ※POSデータCSVから取り込み
- StoreMonthlyFoodCost: 店舗月次理論原価（店舗、対象年月、理論原価合計、売上合計、理論原価率） ※計算結果のスナップショット

### ユーザー・履歴関連（フェーズ2-3）
- User: ユーザー（CHEF / SERVICE / PURCHASER / PRODUCER、Googleアカウント連携情報）
- RecipeHistory: 更新履歴（誰が・いつ・何を変更したか）

### ステータス管理
- Recipeステータス: DRAFT → PUBLISHED ←→ ARCHIVED → DELETED（論理削除）
  - DRAFT: 下書き。作成中のレシピ
  - PUBLISHED: 公開中。店舗で使用中
  - ARCHIVED: アーカイブ。季節メニュー終了時など一時的に非公開。再公開可能
  - DELETED: 論理削除。通常のクエリでは取得されない
- Ingredient供給状態: AVAILABLE（供給可能）/ LIMITED（供給不安定）/ UNAVAILABLE（供給停止）/ SEASONAL（季節限定）

---

## ロール定義

| ロール | 日本語名 | 役割 |
|--------|---------|------|
| CHEF | シェフ | 調理の専門家。レシピの調理面を設計・管理する |
| SERVICE | サービス | 接客の専門家。サービス設計・体験設計を担い、お客様の反応をフィードバックする |
| PURCHASER | 食材調達 | 食材の専門家。食材マスタ・原価情報を管理し、最適な食材調達を行う |
| PRODUCER | 総合プロデューサー | 全体統括。商品戦略・メンバー管理・経営判断を行う |

## 権限モデル

| 操作 | CHEF | SERVICE | PURCHASER | PRODUCER |
|------|------|---------|-----------|----------|
| レシピ作成 | o | x | x | o |
| レシピ更新（調理面: CookingStep, RecipeIngredient） | o | x | x | o |
| レシピ更新（サービス・体験面: ServiceDesign, ExperienceDesign） | o | o | x | o |
| レシピ削除 | o | x | x | o |
| ステータス変更（公開・アーカイブ） | o | x | x | o |
| レシピ閲覧 | o | o | o | o |
| ナレッジ記事の投稿 | o | o | o | o |
| ナレッジ記事の編集・削除 | 自分の記事 | 自分の記事 | 自分の記事 | 全記事 |
| AI相談の利用 | o | o | o | o |
| フィードバック登録 | o | o | x | o |
| フィードバック閲覧 | o | o | o | o |
| 食材マスタ登録・更新 | x | x | o | o |
| 食材価格更新 | x | x | o | o |
| 食材供給状態変更 | x | x | o | o |
| 原価・売価情報の閲覧 | o | x | o | o |
| 売価の更新 | o | x | o | o |
| 影響レシピ一覧の取得 | o | o | o | o |
| 店舗マスタ登録・更新 | x | x | x | o |
| POSデータCSVアップロード | x | o | o | o |
| 店舗別理論原価の閲覧 | o | o | o | o |
| アクセス権限管理（ロール付与・変更） | x | x | x | o |

---

## 認証・認可アーキテクチャ

### Google Workspace SSO
- Google OAuth2/OpenID Connectによるログイン
- 会社ドメイン（Google Workspace管理下）のGoogleアカウントのみログイン許可
- ドメイン制限はOAuth2トークン検証時にメールドメインでチェック
- 初回ログイン時にUserエンティティを自動作成（デフォルトロールはPRODUCERが事前設定 or 申請制）

### JWT
- Google認証成功後、アプリケーション独自のJWTを発行
- JWTにはユーザーID・ロール・有効期限を含む
- 以降のAPI呼び出しはJWTで認証・認可

### アクセス権限管理
- PRODUCERがユーザー一覧からロールを付与・変更できる
- ログイン可能=会社ドメインのGoogleアカウント保持者
- 何ができるか=付与されたロールによって決まる

---

## AI相談機能アーキテクチャ（フェーズ4）

### 概要
商品開発・改良、サービス開発・改良の際に、AIに対話形式で相談できる。
ナレッジベースの記事をコンテキストとして活用し、店舗のフィロソフィーや過去の感動事例に基づいたアドバイスを得られる。

### ナレッジベース
以下のカテゴリでナレッジ記事を蓄積する:
- **調理技法**: 食材の活かし方、調理の工夫、プロの技
- **演出方法**: 盛り付け、照明、音楽、香り、サプライズ演出
- **サービス手法**: 接客話法、おもてなしの心得、クレーム対応の好事例
- **発信方法**: SNS映え、メニュー説明文の書き方、ストーリーの伝え方
- **歴史・文化**: 料理の起源、食文化、地域性、食材の物語
- **感動事例**: 実際にお客様に感動を届けた事例、成功パターン

### AI相談フロー
1. ユーザーが相談テーマを選択（新商品開発、既存メニュー改良、サービス改善 等）
2. 関連するレシピがあれば紐づけ
3. システムがナレッジベースから関連記事を検索し、LLMのコンテキストに含める
4. ユーザーとAIが対話形式で相談
5. 相談履歴はスレッドとして保存され、後から振り返り可能

### フロントエンド画面設計

#### 画面構成

AI相談機能は2つのページで構成する:

**1. AI相談メインページ (`/ai`, `/ai/threads/:threadId`)**

2ペイン（左右分割）レイアウト:

```
┌──────────────┬─────────────────────────────┐
│ スレッド一覧   │  チャットエリア               │
│ (幅: 300px)  │  (残りの幅)                  │
│              │                             │
│ [+新規相談]   │  テーマ: ○○○                 │
│              │  関連レシピ: △△△              │
│ ▶ スレッド1   │                             │
│   スレッド2   │  ┌─────────────────────┐    │
│   スレッド3   │  │ USER: メッセージ...    │    │
│              │  └─────────────────────┘    │
│              │  ┌─────────────────────┐    │
│              │  │ AI: 回答...           │    │
│              │  │ [参考: 記事1] [記事2]  │    │
│              │  └─────────────────────┘    │
│              │                             │
│              │  ┌─────────────────────┐    │
│              │  │ メッセージを入力...     │ 送信│
│              │  └─────────────────────┘    │
└──────────────┴─────────────────────────────┘
```

- 左ペイン: 自分のスレッド一覧（更新日時の新しい順）。ページネーション対応
- 右ペイン: 選択中のスレッドのチャット画面
- スレッド未選択時: 右ペインに「相談を選択するか、新規相談を始めてください」と表示
- モバイル時: 左ペインを折りたたみメニューに変更（ハンバーガーボタンで開閉）

**2. 新規相談作成ページ (`/ai/new`)**

```
┌─────────────────────────────────────────────┐
│ 新規AI相談                                    │
├─────────────────────────────────────────────┤
│                                             │
│ 相談テーマ *                                  │
│ ┌─────────────────────────────────────┐     │
│ │ 例: 春の新作デザートのサービス演出      │     │
│ └─────────────────────────────────────┘     │
│                                             │
│ 関連レシピ（任意）                             │
│ ┌──────────────────────────────┐            │
│ │ レシピを検索...          [▼] │            │
│ └──────────────────────────────┘            │
│                                             │
│ 最初のメッセージ *                             │
│ ┌─────────────────────────────────────┐     │
│ │ AIに相談したい内容を入力...            │     │
│ │                                     │     │
│ │                                     │     │
│ └─────────────────────────────────────┘     │
│                                             │
│                         [相談を始める]        │
└─────────────────────────────────────────────┘
```

- 相談テーマ: 必須、最大200文字
- 関連レシピ: 任意、既存レシピからドロップダウンで選択
- 最初のメッセージ: 必須、テキストエリア
- 送信後: AI相談メインページの該当スレッドに自動遷移

#### チャットUI仕様

**メッセージ表示**:
- USERメッセージ: 右寄せ、背景色付き（例: 青系）
- AIメッセージ: 左寄せ、背景色付き（例: グレー系）、Markdownレンダリング対応
- AIメッセージの参考記事: メッセージ下部にリンクバッジとして表示。クリックでナレッジ記事詳細に遷移
- タイムスタンプ: 各メッセージの下に小さく表示

**メッセージ入力・送信**:
- テキストエリア + 送信ボタン
- Enter で送信、Shift+Enter で改行
- 送信中は入力欄を無効化し、ローディングインジケーターを表示
- 空メッセージは送信不可（ボタン無効化）

**スクロール**:
- 新しいメッセージが追加されたら自動で最下部にスクロール
- チャットエリアは独立スクロール（ページ全体はスクロールしない）

#### 対応するバックエンドAPI

| 操作 | API | 画面 |
|------|-----|------|
| スレッド作成 | `POST /api/ai/threads` | 新規相談作成ページ |
| スレッド一覧取得 | `GET /api/ai/threads` | 左ペイン |
| スレッド詳細取得 | `GET /api/ai/threads/{threadId}` | チャットヘッダー |
| メッセージ一覧取得 | `GET /api/ai/threads/{threadId}/messages` | チャットエリア |
| メッセージ送信 | `POST /api/ai/threads/{threadId}/messages` | メッセージ入力欄 |

#### フロントエンドファイル構成

- `src/api/ai.ts` — API呼び出し関数
- `src/hooks/useAi.ts` — TanStack Query hooks（スレッド一覧・メッセージ取得・送信）
- `src/pages/ai/AiConsultationPage.tsx` — 2ペインメインページ
- `src/pages/ai/AiNewThreadPage.tsx` — 新規相談作成ページ
- `src/components/ai/ThreadList.tsx` — スレッド一覧（左ペイン）
- `src/components/ai/ChatMessage.tsx` — チャット吹き出し（USER/AI切り替え）
- `src/components/ai/ChatInput.tsx` — メッセージ入力欄
- `src/components/ai/ReferencedArticles.tsx` — 参考ナレッジ記事のリンク表示

#### アクセス権限

- 全ロール（CHEF, SERVICE, PURCHASER, PRODUCER）が利用可能
- 自分のスレッドのみ表示・操作可能（PRODUCERは全スレッドにアクセス可能）

---

## コーディング規約

### 命名規則

- 変数名・メソッド名: lowerCamelCase
  - 良い例: recipeId, getIngredientList(), isPublished
  - 悪い例: recipe_id, RecipeID, get_ingredient_list()
- クラス名: UpperCamelCase
  - 良い例: RecipeService, CookingStepRepository
  - 悪い例: recipeService, recipe_service
- 定数: UPPER_SNAKE_CASE
  - 良い例: MAX_RECIPE_TITLE_LENGTH, DEFAULT_PAGE_SIZE
  - 悪い例: maxRecipeTitleLength, max_recipe_title_length

### 例外処理

- 素のRuntimeExceptionは禁止。必ずカスタム例外を使う
- 例外の種類によってHTTPステータスコードを自動マッピングする:
  - BusinessLogicException → 400 Bad Request
  - ResourceNotFoundException → 404 Not Found
  - UnauthorizedException → 401 Unauthorized
  - ForbiddenException → 403 Forbidden
  - ApplicationException → 500 Internal Server Error

### Repository層

- 戻り値はOptional型で統一する
  - 良い例: Optional<Recipe> findByRecipeId(Long recipeId)
  - 悪い例: Recipe findByRecipeId(Long recipeId)

---

## アーキテクチャ

- Controller → Service → Repository の3層構造を守る
- 各層の責務:
  - Controller: リクエストの受付、バリデーション、レスポンス整形
  - Service: ビジネスロジック、権限チェック、トランザクション管理
  - Repository: データアクセス
- DTOとEntityは必ず分離する。Entityを直接レスポンスに使わない
- レシピ更新時は必ずRecipeHistoryに変更履歴を記録する

### 食材マスタと原価管理のルール

- 食材はマスタ（Ingredient）で一元管理し、RecipeIngredientはマスタへの参照を持つ
  - 同じ食材を複数レシピで共有し、価格変更を1箇所で反映可能にする
- 食材価格はIngredientPriceで時系列管理する（有効開始日〜有効終了日）
  - 現在有効な価格 = 有効開始日 <= 現在日 かつ 有効終了日がnullまたは現在日以降
- レシピ原価は自動計算する:
  - レシピ原価 = Σ（各食材の現在単価 × 使用量）
  - 推奨売価 = レシピ原価 ÷ (1 - 目標粗利率)
- 食材の価格・供給状態が変更された場合、影響を受けるレシピの一覧を取得できるAPIを提供する
- 食材変更時の通知フロー:
  1. 調達係が食材マスタ（価格・供給状態）を更新
  2. 影響を受けるレシピの原価を再計算
  3. 粗利率が目標を下回るレシピを警告リストとして返す
  4. シェフが警告リストを確認し、レシピ見直し or 売価変更を判断

### アーカイブ機能のルール

- アーカイブは論理的な非公開状態であり、データは保持される
- アーカイブされたレシピは通常の一覧APIでは返さない（フィルタで取得可能）
- アーカイブからPUBLISHEDへの復元が可能（季節メニューの再開など）
- アーカイブ時・復元時もRecipeHistoryに記録する
- 食材のUNAVAILABLE化に伴い、該当食材を使うレシピの一括アーカイブ候補を提示できる

### POSデータ取り込みと理論原価のルール

- POSデータはCSVファイルで店舗別にアップロードする
  - CSVフォーマット: 店舗コード, レシピコード, 対象年月(YYYY-MM), 出数, 売上金額
  - アップロード時にバリデーション（存在しない店舗コード・レシピコードのエラー検出）を行う
  - 同一店舗・同一年月の再アップロードは上書き（既存データを置換）とする
- 理論原価の計算:
  - 商品別理論原価 = レシピ原価（RecipeCost.totalIngredientCost）× 出数
  - 店舗月次理論原価 = Σ（各商品の理論原価）
  - 理論原価率 = 店舗月次理論原価 ÷ 売上合計 × 100
- 計算結果はStoreMonthlyFoodCostにスナップショットとして保存する
  - 食材価格の変更後に再計算APIで最新の原価に基づいた再計算が可能
- 店舗間の理論原価率比較、月次推移の取得APIを提供する

### フィードバックと改善サイクルのルール

- 商品（レシピ）ごとに満足度・感動度（仮）を記録できる
- フィードバックはレシピ・店舗・期間に紐づけて管理する
- 定期的な集計（FeedbackSummary）により、商品の評価傾向を可視化する
- フィードバックの低い商品はレシピ改善のトリガーとする
- フェーズ7では満足度×収益のクロス分析により、「感動度は高いが収益性が低い」等の戦略的インサイトを提供する

---

## テスト方針

- Service層: JUnit 5 + Mockito で単体テスト必須
- Controller層: @WebMvcTest でAPIテスト
- Repository層: @DataJpaTest でクエリ検証
- テストメソッド名は日本語可: `レシピ作成_正常系_シェフが作成できる()`

## ビルド・実行コマンド

```bash
# ビルド
./gradlew build

# テスト実行
./gradlew test

# アプリケーション起動
./gradlew bootRun

# Flywayマイグレーション
./gradlew flywayMigrate
```

## 禁止事項

- System.out.println()でのログ出力 → SLF4J（@Slf4j）を使うこと
- マジックナンバーの直書き → 定数クラスに定義すること
- SQLの直書き → Spring Data JPAのRepositoryメソッドを使うこと
- Controllerから直接Repositoryを呼ぶこと → 必ずServiceを経由すること
- Entityをレスポンスに直接返すこと → 必ずDTOに変換すること
- レシピ更新時に履歴記録を省略すること → 必ずRecipeHistoryに記録すること
- RecipeIngredientに食材名を直接保持すること → 必ずIngredient（食材マスタ）への参照を使うこと
- 食材価格をIngredientエンティティに直接保持すること → 必ずIngredientPrice（価格履歴）で時系列管理すること
- 原価計算をController層で行うこと → 必ずService層で計算ロジックを実装すること
- レシピの物理削除 → 必ず論理削除（ステータスをDELETEDに変更）を使うこと
- CSVパース処理をController層で行うこと → 必ずService層でパース・バリデーションを実装すること
- 理論原価の計算結果を保存せずに毎回再計算すること → StoreMonthlyFoodCostにスナップショットを保存すること
- AI相談のプロンプトをController層で組み立てること → 必ずai/パッケージまたはService層で管理すること
- ナレッジ記事の本文にHTMLを直接保存すること → Markdown形式で保存し、フロントエンド側でレンダリングすること
